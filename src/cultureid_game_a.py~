#!/usr/bin/env python

import threading
import rospy
from smach import State,StateMachine
from std_msgs.msg import Empty
import math
import rospkg
import time
import os
import subprocess


################################################################################
################################################################################
class GotoInitPose(State):

  ############################################################################
  def __init__(self):
    State.__init__(self, outcomes=['success'], input_keys=['g_counter'], output_keys=['g_counter'])

    # Topics. They should match those
    # of pkg `cultureid_waypoints_following/config/params.yaml`
    self.waypoint_following_node_name = "/" + rospy.get_param('~waypoint_following_node_name', 'cultureid_waypoints_following')
    self.file_waypoints_ready_topic = self.waypoint_following_node_name + "/" + rospy.get_param('~file_waypoints_ready_topic', 'file_waypoints_ready')
    self.go_to_next_waypoint_trigger_topic = self.waypoint_following_node_name + "/" + rospy.get_param('~go_to_next_waypoint_trigger_topic', 'go_to_next_waypoint_trigger')
    self.stopped_at_waypoint_topic = self.waypoint_following_node_name + "/" + rospy.get_param('~stopped_at_waypoint_topic', 'stopped_at_waypoint')

    # Create publisher to publish empty msg that triggers the robot to go to
    # THE VERY FIRST pose of the game. This pose is where the audience first
    # starts playing the game. The very first pose should be set as the pose
    # at the very top in the
    # `cultureid_waypoints_following/saved_path/xxx_pose_0` .csv file and
    # at the last column it should have a 1 marking it (the robot should
    # stop there after arriving there)
    self.goto_start_pose_pub = rospy.Publisher(self.file_waypoints_ready_topic, Empty, queue_size=1)

    # Create publisher to publish empty msg that triggers the robot to go to
    # the next init pose. Each init pose should be marked in the
    # `cultureid_waypoints_following/saved_path/xxx_pose_0` .csv file
    # by a 1 at the very last column (the robot should stop at that pose
    # and wait further instructions)
    self.goto_next_pose_pub = rospy.Publisher(self.go_to_next_waypoint_trigger_topic, Empty, queue_size=1)

    rospy.sleep(2)


  ############################################################################
  def execute(self, userdata):

    # This is the `g_counter`-{st|nd|rd|th} part of the game
    userdata.g_counter = userdata.g_counter + 1

    empty_msg = Empty()
    if userdata.g_counter == 1: # If this is the first time go to the start pose
      self.goto_start_pose_pub.publish(empty_msg)
    else:                       # If not go to the next init pose
      self.goto_next_pose_pub.publish(empty_msg)

    # Wait for the robot to go to the designated pose
    rospy.wait_for_message(self.stopped_at_waypoint_topic, Empty)

    # Path is ready! return success and move on to the next state (FOLLOW_PATH)
    return 'success'


################################################################################
################################################################################
class ShowGui(State):

  ############################################################################
  def __init__(self):
    State.__init__(self, outcomes=['success'], input_keys=['g_counter'], output_keys=['g_counter'])
    self.ppkg = rospy.get_param('~ppkg', '/home/cultureid_user0/catkin_ws/src/cultureid_games')

  ############################################################################
  def execute(self, userdata):

    # Show the GUI. THE GUI *DOES NOT* BLOCK EXECUTION
    # The gui shows itself, a video, and then instructions until we need to
    #
    py_gui_a = self.ppkg + '/src/gui_a.py'
    cmd_gui_a = 'python ' + py_gui_a + ' &'
    os.system(cmd_gui_a)

    return 'success'


################################################################################
################################################################################
class ReadRFIDCard(State):

  ############################################################################
  def __init__(self):
    State.__init__(self, outcomes=['success'], input_keys=['g_counter'], output_keys=['g_counter'])
    self.read_rfid_card_alert_topic = rospy.get_param('~read_rfid_card_alert_topic', 'read_rfid_card_alert')

  ############################################################################
  def execute(self, userdata):

    rospy.logwarn('WAITING TO READ RFID CARD')
    rospy.wait_for_message(self.read_rfid_card_alert_topic, Empty)
    rospy.logwarn('READING RFID CARD')

    return 'success'




################################################################################
################################################################################
def main():

  # Init node
  rospy.init_node('cultureid_game_a')

  #global this_node_name
  #this_node_name = rospy.get_name().lstrip('/')

  sm = StateMachine(outcomes=['success'])
  sm.userdata.g_counter = 0

  with sm:

    StateMachine.add('GOTO_INIT_POSE', GotoInitPose(),
                       transitions={'success':'SHOW_GUI'},
                       remapping={'g_counter':'g_counter'})
    StateMachine.add('SHOW_GUI', ShowGui(),
                       transitions={'success':'READ_RFID_CARD'},
                       remapping={'g_counter':'g_counter'})
    StateMachine.add('READ_RFID_CARD', ReadRFIDCard(),
                       transitions={'success':'READ_RFID_CARD'},
                       remapping={'g_counter':'g_counter'})
    """
    StateMachine.add('GOTO_INIT_POSE', GotoInitPose(),
                       transitions={'success':'SHOW_GUI'},
                       remapping={'g_counter':'g_counter'})
    StateMachine.add('SHOW_GUI', ShowGui(),
                       transitions={'success':'READ_RFID_CARD'},
                       remapping={'g_counter':'g_counter'})
    StateMachine.add('READ_RFID_CARD', ReadRFIDCard(),
                       transitions={'success':'SHOW_INSTRUCTION_2'},
                       remapping={'g_counter':'g_counter'})
    StateMachine.add('SHOW_INSTRUCTION_2', ShowInstruction2(),
                       transitions={'success':'GOTO_INIT_POSE',
                                    'end':'END_STATE'},
                       remapping={'g_counter':'g_counter'})
    StateMachine.add('END_STATE', EndState(),
                       transitions={},
                       remapping={'g_counter':'g_counter'})
    """
  outcome = sm.execute()



################################################################################
################################################################################
if __name__ == '__main__':
  main()
